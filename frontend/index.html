<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comparaci√≥n de Algoritmos de Caminos M√°s Cortos</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            padding: 20px;
        }
        
        .sidebar {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            height: fit-content;
        }
        
        .section {
            margin-bottom: 25px;
        }
        
        .section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }
        
        select, input, button {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
            margin-top: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        #map {
            width: 100%;
            height: 500px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .metric-card h4 {
            color: #667eea;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        
        .metric-card .value {
            font-size: 2em;
            font-weight: bold;
            color: #333;
        }
        
        .metric-card .unit {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        
        .chart-container {
            margin-top: 20px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .status {
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .checkbox-item input[type="checkbox"] {
            width: auto;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .loading.active {
            display: block;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .comparison-table th,
        .comparison-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        .comparison-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
        }
        
        .comparison-table tr:hover {
            background: #f8f9fa;
        }
        
        .best-value {
            background: #d4edda !important;
            font-weight: bold;
            color: #155724;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üöÄ Algoritmos de Caminos M√°s Cortos</h1>
            <p>Comparaci√≥n de rendimiento con aceleraci√≥n CUDA para redes viales urbanas de Per√∫</p>
        </header>
        
        <div class="main-content">
            <!-- Sidebar de controles -->
            <div class="sidebar">
                <div class="section">
                    <h3>üìç Seleccionar Ubicaci√≥n</h3>
                    <div class="form-group">
                        <label>Departamento:</label>
                        <select id="regionSelect" onchange="loadProvincias()">
                            <option value="">Seleccionar departamento...</option>
                        </select>
                    </div>
                    
                    <button onclick="cargarMapaRegion()" class="btn-primary" style="width: 100%; padding: 10px; margin: 10px 0; background: #2ecc71;">
                        üó∫Ô∏è Cargar Mapa OSM
                    </button>
                    
                    <button onclick="cargarMapaMTC()" class="btn-primary" style="width: 100%; padding: 10px; margin: 10px 0; background: #3498db;">
                        üèõÔ∏è Cargar Red Vial Oficial MTC
                    </button>
                    
                    <div id="mapLoadStatus" style="padding: 8px; margin: 8px 0; border-radius: 5px; display:none; font-size: 0.85em;"></div>
                    
                    <div class="form-group" id="provinciaGroup" style="display:none;">
                        <label>Provincia:</label>
                        <select id="provinciaSelect" onchange="loadDistritos()">
                            <option value="">Seleccionar provincia...</option>
                        </select>
                    </div>
                    <div class="form-group" id="distritoGroup" style="display:none;">
                        <label>Distrito:</label>
                        <select id="distritoSelect" onchange="checkMapStatus()">
                            <option value="">Seleccionar distrito...</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>üìç Ingresa tu direcci√≥n:</label>
                        <input type="text" id="addressInput" placeholder="Plaza de Armas" style="width: 100%; padding: 8px;">
                        <small style="color: #666;">Ejemplos: Plaza de Armas, Av. Sol, Qorikancha, Hospital Regional</small>
                    </div>
                    
                    <button onclick="ubicarYBuscarHospitales()" class="btn-primary" style="width: 100%; padding: 12px; margin-top: 10px; font-size: 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                        üìç Ubicar y Buscar Hospitales
                    </button>
                    
                    <div id="mapStatus" style="padding: 10px; margin: 10px 0; border-radius: 5px; display:none;"></div>
                </div>
                
                <div id="statusDiv"></div>
                
                <div class="section" id="hospitalSection" style="display:none;">
                    <h3>üè• Ruta a Hospitales</h3>
                    <div id="locationInfo" style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                        <p><strong>Tu ubicaci√≥n:</strong></p>
                        <p id="userLocationText" style="margin: 5px 0; font-size: 0.9em;"></p>
                    </div>
                    
                    <div id="hospitalesEncontrados" style="display:none;">
                        <p><strong>Hospitales encontrados:</strong></p>
                        <div id="hospitalesList" style="max-height: 200px; overflow-y: auto; margin-bottom: 10px;"></div>
                        
                        <button onclick="calcularRutasAutomatico()" style="width: 100%; background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; padding: 12px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">
                            üöë Calcular Rutas √ìptimas
                        </button>
                    </div>
                </div>
                
                <div class="section">
                    <h3>‚öôÔ∏è Configuraci√≥n</h3>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="useCuda" checked onchange="toggleCudaInfo()">
                            Usar aceleraci√≥n CUDA
                        </label>
                        <div style="font-size: 0.8em; color: #555; margin-top: 4px;">
                            Marcar = intentar usar GPU (CUDA); desmarcar = forzar uso solo de CPU.
                            Si CUDA/CuPy no est√°n disponibles en el backend, siempre se usar√° CPU.
                        </div>
                    </div>
                    <div id="cudaInfo" style="display:none; margin-top: 10px; padding: 10px; background: #e3f2fd; border-radius: 5px; font-size: 0.85em;"></div>
                </div>
                
                <div class="section">
                    <h3>üî¨ Algoritmos</h3>
                    <div class="checkbox-group" id="algorithmCheckboxes">
                        <div class="checkbox-item">
                            <input type="checkbox" id="algo_dijkstra" value="dijkstra" checked>
                            <label for="algo_dijkstra">Dijkstra</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="algo_duan" value="duan2025" checked>
                            <label for="algo_duan">Duan et al. (2025)</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="algo_khanna" value="khanna2022" checked>
                            <label for="algo_khanna">Khanna et al. (2022)</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="algo_wang" value="wang2021" checked>
                            <label for="algo_wang">Wang et al. (2021)</label>
                        </div>
                    </div>
                    <button onclick="compareAlgorithms()">Comparar Algoritmos</button>
                </div>
            </div>
            
            <!-- √Årea principal -->
            <div class="main-area">
                <div class="section">
                    <h3>üó∫Ô∏è Visualizaci√≥n del Grafo</h3>
                    <div id="map"></div>
                </div>
                
                <div class="loading" id="loadingDiv">
                    <div class="spinner"></div>
                    <p>Procesando algoritmos...</p>
                </div>
                
                <div id="resultsDiv"></div>
            </div>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        const API_URL = 'http://localhost:8000/api';
        let map;
        let graphData = null;
        let graphLoaded = false; // Flag para saber si el grafo backend est√° cargado
        let currentMarkers = [];
        let currentPaths = [];
        let userMarker = null;
        let hospitalMarkers = [];
        let userLocation = null; // {lat, lon, address}
        let selectedRegion = null;
        let nearbyHospitals = [];
        
        // Inicializar mapa
        function initMap() {
            map = L.map('map').setView([-12.046, -77.043], 13);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
            
            // Permitir click en mapa para seleccionar ubicaci√≥n
            map.on('click', function(e) {
                setUserLocation(e.latlng.lat, e.latlng.lng, 'Ubicaci√≥n seleccionada en mapa');
            });
        }
        
        // Establecer ubicaci√≥n del usuario
        function setUserLocation(lat, lon, address) {
            userLocation = { lat, lon, address };
            
            // Remover marcador anterior
            if (userMarker) {
                map.removeLayer(userMarker);
            }
            
            // Crear nuevo marcador
            userMarker = L.marker([lat, lon], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map);
            
            userMarker.bindPopup(`<b>Tu ubicaci√≥n</b><br>${address}<br>Lat: ${lat.toFixed(5)}, Lon: ${lon.toFixed(5)}`).openPopup();
            map.setView([lat, lon], 15);
            
            // Actualizar UI
            document.getElementById('userLocationText').innerHTML = `
                <strong>${address}</strong><br>
                üìç Lat: ${lat.toFixed(5)}, Lon: ${lon.toFixed(5)}
            `;
            document.getElementById('hospitalSection').style.display = 'block';
            
            showStatus('‚úÖ Ubicaci√≥n establecida. Buscando hospitales cercanos...', 'success');
            
            // BUSCAR HOSPITALES AUTOM√ÅTICAMENTE
            setTimeout(() => {
                buscarHospitalesCercanos();
            }, 500);
        }
        
        // Geocodificar direcci√≥n usando Nominatim
        async function geocodeAddress() {
            const address = document.getElementById('addressInput').value.trim();
            const region = document.getElementById('regionSelect').value;
            const provincia = document.getElementById('provinciaSelect').value;
            const distrito = document.getElementById('distritoSelect').value;
            
            if (!address || address.length < 3) {
                alert('Ingresa una direcci√≥n v√°lida (m√≠nimo 3 caracteres).\nEjemplos: Plaza de Armas, Av. Sol, Qorikancha');
                return;
            }
            
            if (!region) {
                alert('Selecciona un departamento primero');
                return;
            }
            
            // Obtener nombres completos
            const distritoSelect = document.getElementById('distritoSelect');
            const provinciaSelect = document.getElementById('provinciaSelect');
            const regionSelect = document.getElementById('regionSelect');
            
            const distritoName = distrito ? distritoSelect.options[distritoSelect.selectedIndex].text : '';
            const provinciaName = provincia ? provinciaSelect.options[provinciaSelect.selectedIndex].text : '';
            const regionName = regionSelect.options[regionSelect.selectedIndex].text.replace(' (üíæ)', '').split(' (')[0];
            
            // Limpiar direcci√≥n: eliminar n√∫meros de casa para b√∫squeda m√°s amplia
            let cleanAddress = address.replace(/#\d+/g, '').replace(/\d+/g, '').trim();
            
            // Intentar m√∫ltiples b√∫squedas en cascada
            const queries = [
                // 1. Direcci√≥n + distrito + provincia + departamento
                `${cleanAddress}, ${distritoName}, ${provinciaName}, ${regionName}, Peru`,
                // 2. Direcci√≥n + departamento
                `${cleanAddress}, ${regionName}, Peru`,
                // 3. Solo direcci√≥n + Peru
                `${cleanAddress}, Peru`,
                // 4. Direcci√≥n original completa
                `${address}, ${regionName}, Peru`
            ].filter(q => q.length > 10);
            
            showStatus(`üîç Buscando: ${cleanAddress}...`, 'info');
            
            for (let query of queries) {
                try {
                    const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=1`);
                    const data = await response.json();
                    
                    if (data.length > 0) {
                        const lat = parseFloat(data[0].lat);
                        const lon = parseFloat(data[0].lon);
                        setUserLocation(lat, lon, `${address}`);
                        return; // √âxito, salir
                    }
                } catch (error) {
                    console.error('Error en b√∫squeda:', error);
                }
            }
            
            // Si ninguna b√∫squeda funcion√≥
            showStatus(`‚ùå No se encontr√≥ "${cleanAddress}". Usa nombres conocidos: Plaza de Armas, Av. Sol, Qorikancha, o haz clic en el mapa.`, 'error');
        }
        
        // FUNCI√ìN PRINCIPAL: Ubicar direcci√≥n y buscar hospitales autom√°ticamente
        // Cargar mapa de la regi√≥n seleccionada (OpenStreetMap)
        async function cargarMapaRegion() {
            const region = document.getElementById('regionSelect').value;
            const mapLoadStatusDiv = document.getElementById('mapLoadStatus');
            
            if (!region) {
                alert('Selecciona un departamento primero');
                return;
            }
            
            selectedRegion = region;
            mapLoadStatusDiv.style.display = 'block';
            mapLoadStatusDiv.style.background = '#fff3cd';
            mapLoadStatusDiv.innerHTML = '‚è≥ Cargando grafo desde OpenStreetMap...';
            
            try {
                const response = await fetch(`${API_URL}/download_region`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ region_key: region, network_type: 'drive' })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    graphLoaded = true; // Marcar grafo como cargado
                    mapLoadStatusDiv.style.background = '#d4edda';
                    mapLoadStatusDiv.innerHTML = `‚úÖ <strong>OSM cargado:</strong> ${data.num_nodes.toLocaleString()} nodos, ${data.num_edges.toLocaleString()} aristas<br><small>Fuente: ${data.source || 'OpenStreetMap'}</small>`;
                    showStatus(`‚úÖ Mapa OSM de ${region} cargado exitosamente`, 'success');
                } else {
                    mapLoadStatusDiv.style.background = '#f8d7da';
                    mapLoadStatusDiv.innerHTML = '‚ùå Error al cargar el grafo';
                    showStatus('‚ùå Error al cargar mapa', 'error');
                }
            } catch (error) {
                mapLoadStatusDiv.style.background = '#f8d7da';
                mapLoadStatusDiv.innerHTML = `‚ùå Error: ${error.message}`;
                showStatus('‚ùå Error al cargar mapa', 'error');
            }
        }
        
        // Cargar red vial oficial del MTC
        async function cargarMapaMTC() {
            const region = document.getElementById('regionSelect').value;
            const mapLoadStatusDiv = document.getElementById('mapLoadStatus');
            
            if (!region) {
                alert('Selecciona un departamento primero');
                return;
            }
            
            selectedRegion = region;
            mapLoadStatusDiv.style.display = 'block';
            mapLoadStatusDiv.style.background = '#fff3cd';
            mapLoadStatusDiv.innerHTML = '‚è≥ Cargando red vial oficial del MTC...<br><small>‚è±Ô∏è Puede tardar 15-30 segundos (grafo de 1.8M nodos)</small>';
            
            try {
                // Crear AbortController con timeout extendido de 60 segundos
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);
                
                const response = await fetch(`${API_URL}/download_mtc?region_key=${region}&incluir_vecinal=true`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Error al cargar red vial MTC');
                }
                
                const data = await response.json();
                
                if (data.success) {
                    // Marcar grafo como cargado
                    graphLoaded = true;
                    
                    mapLoadStatusDiv.style.background = '#d4edda';
                    mapLoadStatusDiv.innerHTML = `‚úÖ <strong>Red Vial MTC cargada:</strong> ${data.num_nodes.toLocaleString()} nodos, ${data.num_edges.toLocaleString()} aristas<br><small>üèõÔ∏è Fuente: ${data.source}</small><br><small>Incluye v√≠as vecinales: ${data.incluye_vecinal ? 'S√≠' : 'No'}</small>`;
                    showStatus(`‚úÖ Red vial oficial MTC de ${region} cargada exitosamente`, 'success');
                    
                    // Centrar mapa en la regi√≥n seg√∫n coordenadas
                    const regionCenters = {
                        'cusco': [-13.5319, -71.9675],
                        'lima': [-12.046, -77.043],
                        'arequipa': [-16.4090, -71.5375],
                        'trujillo': [-8.1116, -79.0288],
                        'piura': [-5.1945, -80.6328]
                    };
                    
                    if (regionCenters[region]) {
                        map.setView(regionCenters[region], 13);
                        console.log(`üó∫Ô∏è Mapa centrado en ${region}:`, regionCenters[region]);
                    }
                } else {
                    mapLoadStatusDiv.style.background = '#f8d7da';
                    mapLoadStatusDiv.innerHTML = '‚ùå Error al cargar red vial MTC';
                    showStatus('‚ùå Error al cargar red vial MTC', 'error');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    mapLoadStatusDiv.style.background = '#f8d7da';
                    mapLoadStatusDiv.innerHTML = '‚ùå Timeout: El grafo es muy grande. Intenta con √°rea.osm.json';
                    showStatus('‚ùå Timeout al cargar MTC', 'error');
                } else {
                    mapLoadStatusDiv.style.background = '#f8d7da';
                    mapLoadStatusDiv.innerHTML = `‚ùå Error: ${error.message}`;
                    showStatus('‚ùå Error al cargar red vial MTC', 'error');
                }
            }
        }
        
        async function ubicarYBuscarHospitales() {
            const region = document.getElementById('regionSelect').value;
            
            if (!region) {
                alert('Selecciona un departamento primero');
                return;
            }
            
            // 1. Verificar si existe mapa
            showStatus('üîç Verificando mapa...', 'info');
            const checkResponse = await fetch(`${API_URL}/check_map?region_key=${region}`, { method: 'POST' });
            const checkData = await checkResponse.json();
            
            // 2. Si no existe, cargar autom√°ticamente
            if (!checkData.exists) {
                showStatus('üì¶ Cargando mapa de la regi√≥n...', 'info');
                const loadResponse = await fetch(`${API_URL}/download_region`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ region_key: region, network_type: 'drive' })
                });
                const loadData = await loadResponse.json();
                if (!loadData.success) {
                    showStatus('‚ùå Error al cargar mapa', 'error');
                    return;
                }
                showStatus(`‚úÖ Mapa cargado: ${loadData.num_nodes} nodos`, 'success');
            }
            
            // 3. Geocodificar direcci√≥n
            await geocodeAddress();
            
            // 4. Si se obtuvo ubicaci√≥n, buscar hospitales (ya se hace autom√°ticamente en setUserLocation)
        }
        
        // Buscar hospitales cercanos autom√°ticamente
        async function buscarHospitalesCercanos() {
            if (!userLocation) {
                await geocodeAddress();
                if (!userLocation) return;
            }
            
            const region = document.getElementById('regionSelect').value;
            if (!region) {
                alert('Selecciona un departamento primero');
                return;
            }
            
            selectedRegion = region;
            showStatus('üè• Buscando hospitales cercanos...', 'info');
            
            try {
                // Obtener hospitales predefinidos del departamento
                const response = await fetch(`${API_URL}/hospitales/${region}`);
                const data = await response.json();
                
                if (!data.hospitales || data.hospitales.length === 0) {
                    showStatus('‚ùå No hay hospitales registrados para esta regi√≥n', 'error');
                    return;
                }
                
                // Calcular distancias
                nearbyHospitals = data.hospitales.map(hospital => {
                    const distance = calculateDistance(
                        userLocation.lat, userLocation.lon,
                        hospital.lat, hospital.lon
                    );
                    return { ...hospital, distance };
                }).sort((a, b) => a.distance - b.distance);
                
                // Mostrar hospitales en el mapa
                displayHospitalsOnMap(nearbyHospitals);
                
                // Mostrar lista con radio buttons para seleccionar UNO
                const listDiv = document.getElementById('hospitalesList');
                listDiv.innerHTML = nearbyHospitals.map((h, i) => `
                    <div style="padding: 3px 6px; margin: 2px 0; background: ${i < 3 ? '#e8f5e9' : '#f9f9f9'}; border-radius: 3px; font-size: 0.75em; border: 1px solid ${i === 0 ? '#4caf50' : '#ccc'}; cursor: pointer;" onclick="selectHospital(${i})">
                        <label style="cursor: pointer; display: flex; align-items: center; gap: 6px;">
                            <input type="radio" name="hospitalSelection" value="${i}" ${i === 0 ? 'checked' : ''} style="margin: 0; width: 12px; height: 12px; flex-shrink: 0;">
                            <div style="line-height: 1.2;">
                                <strong style="font-size: 0.9em;">${i + 1}. ${h.name}</strong><br>
                                <small style="font-size: 0.8em; color: #555;">üìè ${h.distance.toFixed(2)}km ¬∑ ${h.tipo}</small>
                            </div>
                        </label>
                    </div>
                `).join('');
                
                document.getElementById('hospitalesEncontrados').style.display = 'block';
                showStatus(`‚úÖ ${nearbyHospitals.length} hospitales encontrados. Selecciona UNO para calcular ruta.`, 'success');
                
            } catch (error) {
                showStatus('‚ùå Error al buscar hospitales', 'error');
            }
        }
        
        // Mostrar hospitales en el mapa
        function displayHospitalsOnMap(hospitals) {
            // Limpiar marcadores anteriores
            hospitalMarkers.forEach(m => map.removeLayer(m));
            hospitalMarkers = [];
            
            console.log('üìç Mostrando hospitales en mapa:', hospitals.map(h => ({
                name: h.name,
                lat: h.lat,
                lon: h.lon
            })));
            
            hospitals.forEach((hospital, index) => {
                const marker = L.marker([hospital.lat, hospital.lon], {
                    icon: L.icon({
                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
                        iconSize: [25, 41],
                        iconAnchor: [12, 41],
                        popupAnchor: [1, -34],
                        shadowSize: [41, 41]
                    })
                }).addTo(map);
                
                marker.bindPopup(`
                    <b>${index + 1}. ${hospital.name}</b><br>
                    Distancia: ${hospital.distance.toFixed(2)} km<br>
                    Tipo: ${hospital.tipo}<br>
                    Nivel: ${hospital.nivel}
                `);
                
                hospitalMarkers.push(marker);
            });
        }
        
        // Calcular distancia haversine
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radio de la Tierra en km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Seleccionar hospital (marcar radio button y resaltar)
        function selectHospital(index) {
            const radios = document.querySelectorAll('input[name="hospitalSelection"]');
            radios[index].checked = true;
            
            // Resaltar seleccionado
            const divs = document.querySelectorAll('#hospitalesList > div');
            divs.forEach((div, i) => {
                if (i === index) {
                    div.style.border = '2px solid #4caf50';
                    div.style.background = '#e8f5e9';
                } else {
                    div.style.border = '2px solid #ddd';
                    div.style.background = i < 3 ? '#f1f8f4' : '#f5f5f5';
                }
            });
        }
        
        // Calcular ruta al hospital seleccionado
        async function calcularRutasAutomatico() {
            // Verificar que el grafo est√© cargado
            if (!graphLoaded) {
                alert('‚ö†Ô∏è Primero debes cargar la red vial.\n\nHaz clic en "Cargar Red Vial Oficial MTC" o "Descargar Mapa del Distrito"');
                return;
            }
            
            if (!userLocation || nearbyHospitals.length === 0) {
                alert('Primero busca hospitales cercanos');
                return;
            }
            
            // Obtener hospital seleccionado
            const selectedIndex = document.querySelector('input[name="hospitalSelection"]:checked')?.value;
            if (selectedIndex === undefined) {
                alert('Selecciona un hospital primero');
                return;
            }
            
            const selectedHospital = nearbyHospitals[parseInt(selectedIndex)];
            
            showStatus(`üöë Calculando ruta a ${selectedHospital.name}...`, 'info');
            
            try {
                const response = await fetch(`${API_URL}/calculate_hospital_routes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        region_key: selectedRegion,
                        user_lat: userLocation.lat,
                        user_lon: userLocation.lon,
                        hospital_name: selectedHospital.name,  // Enviar hospital espec√≠fico
                        algorithms: getSelectedAlgorithms(),
                        use_cuda: document.getElementById('useCuda').checked
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Error al calcular rutas');
                }
                
                const data = await response.json();
                
                // Filtrar solo rutas del hospital seleccionado si existe
                if (selectedHospital && data.routes) {
                    data.routes = data.routes.filter(r => r.hospital_name === selectedHospital.name);
                }
                if (selectedHospital && data.algorithm_runs) {
                    data.algorithm_runs = data.algorithm_runs.filter(r => r.hospital_name === selectedHospital.name);
                }
                
                displayRouteResults(data);
                
            } catch (error) {
                showStatus(`‚ùå Error: ${error.message}`, 'error');
                console.error('Error al calcular rutas:', error);
            }
        }
        
        // Cargar regiones disponibles
        async function loadRegions() {
            try {
                const response = await fetch(`${API_URL}/regions`);
                const data = await response.json();
                
                const select = document.getElementById('regionSelect');
                data.regions.forEach(region => {
                    const option = document.createElement('option');
                    option.value = region.key;
                    const cacheIcon = region.cached ? 'üíæ ' : '';
                    option.textContent = `${cacheIcon}${region.name} (${region.capital})`;
                    option.title = region.cached ? 'Disponible en cach√© local' : 'Requiere descarga';
                    select.appendChild(option);
                });
                
                checkGraphStatus();
            } catch (error) {
                showStatus('Error al cargar regiones', 'error');
            }
        }
        
        // Cargar provincias cuando se selecciona departamento
        async function loadProvincias() {
            const departamentoKey = document.getElementById('regionSelect').value;
            const provinciaGroup = document.getElementById('provinciaGroup');
            const distritoGroup = document.getElementById('distritoGroup');
            
            // Reset
            document.getElementById('provinciaSelect').innerHTML = '<option value="">Seleccionar provincia...</option>';
            document.getElementById('distritoSelect').innerHTML = '<option value="">Seleccionar distrito...</option>';
            provinciaGroup.style.display = 'none';
            distritoGroup.style.display = 'none';
            document.getElementById('mapStatus').style.display = 'none';
            
            if (!departamentoKey) return;
            
            selectedRegion = departamentoKey;
            
            try {
                const response = await fetch(`${API_URL}/provincias/${departamentoKey}`);
                const data = await response.json();
                
                if (Object.keys(data.provincias).length > 0) {
                    const select = document.getElementById('provinciaSelect');
                    for (const [key, prov] of Object.entries(data.provincias)) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = prov.name;
                        select.appendChild(option);
                    }
                    provinciaGroup.style.display = 'block';
                }
                
                checkMapStatus();
            } catch (error) {
                console.error('Error cargando provincias:', error);
            }
        }
        
        // Cargar distritos cuando se selecciona provincia
        async function loadDistritos() {
            const departamentoKey = document.getElementById('regionSelect').value;
            const provinciaKey = document.getElementById('provinciaSelect').value;
            const distritoGroup = document.getElementById('distritoGroup');
            
            document.getElementById('distritoSelect').innerHTML = '<option value="">Seleccionar distrito...</option>';
            distritoGroup.style.display = 'none';
            document.getElementById('mapStatus').style.display = 'none';
            
            if (!provinciaKey) return;
            
            try {
                const response = await fetch(`${API_URL}/distritos/${departamentoKey}/${provinciaKey}`);
                const data = await response.json();
                
                if (Object.keys(data.distritos).length > 0) {
                    const select = document.getElementById('distritoSelect');
                    for (const [key, dist] of Object.entries(data.distritos)) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = dist.name;
                        select.appendChild(option);
                    }
                    distritoGroup.style.display = 'block';
                }
            } catch (error) {
                console.error('Error cargando distritos:', error);
            }
        }
        
        // Cargar provincias cuando se selecciona regi√≥n
        async function loadProvincias() {
            const regionKey = document.getElementById('regionSelect').value;
            const provinciaGroup = document.getElementById('provinciaGroup');
            const distritoGroup = document.getElementById('distritoGroup');
            
            // Reset
            document.getElementById('provinciaSelect').innerHTML = '<option value="">Seleccionar provincia...</option>';
            document.getElementById('distritoSelect').innerHTML = '<option value="">Seleccionar distrito...</option>';
            provinciaGroup.style.display = 'none';
            distritoGroup.style.display = 'none';
            document.getElementById('mapStatus').style.display = 'none';
            
            if (!regionKey) return;
            
            // Solo Cusco tiene provincias por ahora
            if (regionKey === 'cusco') {
                try {
                    const response = await fetch(`${API_URL}/provincias/${regionKey}`);
                    const data = await response.json();
                    
                    const select = document.getElementById('provinciaSelect');
                    for (const [key, prov] of Object.entries(data.provincias)) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = prov.name;
                        select.appendChild(option);
                    }
                    
                    provinciaGroup.style.display = 'block';
                } catch (error) {
                    console.error('Error cargando provincias:', error);
                }
            } else {
                // Regi√≥n sin subdivisiones - verificar cach√© directamente
                checkMapStatus();
            }
        }
        
        // Verificar estado del mapa (si existe en cach√©)
        async function checkMapStatus() {
            const regionKey = document.getElementById('regionSelect').value;
            const distritoKey = document.getElementById('distritoSelect').value;
            
            if (!regionKey) return;
            
            try {
                const params = new URLSearchParams();
                if (distritoKey) {
                    params.append('distrito_key', distritoKey);
                } else {
                    params.append('region_key', regionKey);
                }
                
                const response = await fetch(`${API_URL}/check_map?${params}`, { method: 'POST' });
                const data = await response.json();
                
                const statusDiv = document.getElementById('mapStatus');
                
                if (statusDiv) {
                    statusDiv.style.display = 'block';
                    
                    if (data.exists) {
                        statusDiv.innerHTML = `‚úÖ ${data.message}`;
                        statusDiv.style.background = '#d4edda';
                        statusDiv.style.color = '#155724';
                    } else {
                        statusDiv.innerHTML = `üì¶ ${data.message}`;
                        statusDiv.style.background = '#e3f2fd';
                        statusDiv.style.color = '#1565c0';
                    }
                }
            } catch (error) {
                console.error('Error verificando mapa:', error);
            }
        }
        
        // Descargar mapa
        async function downloadMap() {
            const departamentoKey = document.getElementById('regionSelect').value;
            const provinciaKey = document.getElementById('provinciaSelect').value;
            const distritoKey = document.getElementById('distritoSelect').value;
            
            if (!departamentoKey) {
                alert('Selecciona un departamento primero');
                return;
            }
            
            showStatus('üì• Descargando mapa... Esto puede tardar varios minutos.', 'info');
            
            try {
                let response;
                if (distritoKey && provinciaKey) {
                    // Descargar distrito espec√≠fico
                    const params = new URLSearchParams({ 
                        departamento_key: departamentoKey,
                        provincia_key: provinciaKey, 
                        distrito_key: distritoKey 
                    });
                    response = await fetch(`${API_URL}/download_distrito?${params}`, { method: 'POST' });
                } else {
                    // Descargar regi√≥n completa
                    response = await fetch(`${API_URL}/download_region`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ region_key: departamentoKey, network_type: 'drive' })
                    });
                }
                
                const data = await response.json();
                showStatus(`‚úÖ ${data.message} - ${data.num_nodes} nodos, ${data.num_edges} aristas`, 'success');
                checkMapStatus();
            } catch (error) {
                showStatus('‚ùå Error al descargar mapa', 'error');
            }
        }
        
        // Cargar mapa desde cach√©
        async function loadCachedMap() {
            showStatus('üì¶ Cargando mapa desde cach√©...', 'info');
            await downloadMap();
        }
        
        // Verificar estado del grafo
        async function checkGraphStatus() {
            try {
                const response = await fetch(`${API_URL}/status`);
                const data = await response.json();
                
                if (data.graph_loaded) {
                    showStatus(`‚úÖ Grafo cargado: ${data.num_nodes} nodos, ${data.num_edges} aristas`, 'success');
                } else {
                    showStatus('‚ÑπÔ∏è No hay grafo cargado. Selecciona una ubicaci√≥n.', 'info');
                }
            } catch (error) {
                console.error('Error verificando estado:', error);
            }
        }
        
        // Descargar regi√≥n desde OSM
        async function downloadRegion() {
            const regionKey = document.getElementById('regionSelect').value;
            if (!regionKey) {
                showStatus('Seleccione una regi√≥n', 'error');
                return;
            }
            
            showStatus('üì¶ Cargando mapa desde datos locales (shapefile)...', 'info');
            
            try {
                const response = await fetch(`${API_URL}/download_region`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({region_key: regionKey, network_type: 'drive'})
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showStatus(`‚úÖ ${data.message}. Nodos: ${data.num_nodes}, Aristas: ${data.num_edges}`, 'success');
                    await loadGraphInfo();
                    await loadRegions(); // Recargar para actualizar √≠conos de cach√©
                } else {
                    showStatus('Error al descargar regi√≥n', 'error');
                }
            } catch (error) {
                showStatus(`Error: ${error.message}. Verifica la terminal del servidor.`, 'error');
            }
        }
        
        // Cargar grafo local
        async function loadLocalGraph() {
            showStatus('Cargando grafo local...', 'info');
            
            try {
                const response = await fetch(`${API_URL}/load_graph`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'}
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showStatus(`‚úÖ ${data.message}. Nodos: ${data.num_nodes}, Aristas: ${data.num_edges}`, 'success');
                    await loadGraphInfo();
                } else {
                    showStatus('Error al cargar grafo', 'error');
                }
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
            }
        }
        
        // Cargar informaci√≥n del grafo
        async function loadGraphInfo() {
            try {
                const response = await fetch(`${API_URL}/graph_info`);
                graphData = await response.json();
                
                // Actualizar l√≠mites del mapa si hay nodos de muestra
                if (graphData.sample_nodes && graphData.sample_nodes.length > 0) {
                    const firstNode = graphData.sample_nodes[0];
                    map.setView([firstNode.lat, firstNode.lon], 13);
                }
            } catch (error) {
                console.error('Error al cargar informaci√≥n del grafo:', error);
            }
        }
        
        // Encontrar nodo m√°s cercano a coordenadas
        async function findNearestNode() {
            const lat = parseFloat(document.getElementById('latitude').value);
            const lon = parseFloat(document.getElementById('longitude').value);
            
            if (isNaN(lat) || isNaN(lon)) {
                showStatus('Ingrese coordenadas v√°lidas', 'error');
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/find_nearest_node`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({lat, lon})
                });
                
                const data = await response.json();
                document.getElementById('sourceNode').value = data.nearest_node;
                
                // Marcar en el mapa
                clearMarkers();
                const marker = L.marker([data.node_info.lat, data.node_info.lon])
                    .addTo(map)
                    .bindPopup(`Nodo ${data.nearest_node}`)
                    .openPopup();
                currentMarkers.push(marker);
                map.setView([data.node_info.lat, data.node_info.lon], 15);
                
                showStatus(`Nodo m√°s cercano: ${data.nearest_node}`, 'success');
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
            }
        }
        
        // Buscar hospitales cercanos
        async function findNearestHospitals() {
            const lat = parseFloat(document.getElementById('latitude').value);
            const lon = parseFloat(document.getElementById('longitude').value);
            
            if (isNaN(lat) || isNaN(lon)) {
                showStatus('Ingrese coordenadas v√°lidas', 'error');
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/find_hospitals`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({lat, lon})
                });
                
                const data = await response.json();
                
                // Marcar hospitales en el mapa
                clearMarkers();
                
                // Marcar ubicaci√≥n del usuario
                const userMarker = L.marker([lat, lon], {
                    icon: L.icon({
                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                        iconSize: [25, 41],
                        iconAnchor: [12, 41]
                    })
                }).addTo(map).bindPopup('üìç Tu ubicaci√≥n').openPopup();
                currentMarkers.push(userMarker);
                
                // Marcar hospitales
                data.nearest_hospitals.forEach((hospital, idx) => {
                    const hospitalMarker = L.marker([hospital.lat, hospital.lon], {
                        icon: L.icon({
                            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                            iconSize: [25, 41],
                            iconAnchor: [12, 41]
                        })
                    }).addTo(map).bindPopup(`
                        <strong>üè• ${hospital.name}</strong><br>
                        Distancia: ${hospital.distance_direct_km.toFixed(2)} km
                    `);
                    currentMarkers.push(hospitalMarker);
                });
                
                // Ajustar vista del mapa
                const bounds = L.latLngBounds(
                    data.nearest_hospitals.map(h => [h.lat, h.lon]).concat([[lat, lon]])
                );
                map.fitBounds(bounds, {padding: [50, 50]});
                
                showStatus(`‚úÖ Encontrados ${data.nearest_hospitals.length} hospitales cercanos`, 'success');
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
            }
        }
        
        // Calcular rutas a hospitales
        async function calculateHospitalRoutes() {
            const lat = parseFloat(document.getElementById('latitude').value);
            const lon = parseFloat(document.getElementById('longitude').value);
            const regionKey = document.getElementById('regionSelect').value || 'cusco';
            const useCuda = document.getElementById('useCuda').checked;
            
            if (isNaN(lat) || isNaN(lon)) {
                showStatus('Ingrese coordenadas v√°lidas', 'error');
                return;
            }
            
            document.getElementById('loadingDiv').classList.add('active');
            document.getElementById('resultsDiv').innerHTML = '';
            
            try {
                const response = await fetch(`${API_URL}/calculate_hospital_routes`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        region_key: regionKey,
                        user_lat: lat,
                        user_lon: lon,
                        algorithms: ['dijkstra', 'duan2025'],
                        use_cuda: useCuda
                    })
                });
                
                const data = await response.json();
                
                document.getElementById('loadingDiv').classList.remove('active');
                
                if (data.success) {
                    displayHospitalRoutes(data);
                    showStatus('‚úÖ Rutas a hospitales calculadas', 'success');
                } else {
                    showStatus('Error al calcular rutas', 'error');
                }
            } catch (error) {
                document.getElementById('loadingDiv').classList.remove('active');
                showStatus(`Error: ${error.message}`, 'error');
            }
        }
        
        // Mostrar resultados de rutas a hospitales
        function displayHospitalRoutes(data) {
            const resultsDiv = document.getElementById('resultsDiv');
            
            let html = '<div class="section"><h3>üè• Rutas √ìptimas a Hospitales</h3>';
            
            // Tabla de resultados
            html += '<table class="comparison-table"><thead><tr>';
            html += '<th>Hospital</th><th>Algoritmo</th><th>Distancia (km)</th><th>Tiempo (s)</th><th>Nodos</th>';
            html += '</tr></thead><tbody>';
            
            data.hospital_routes.forEach(hospital => {
                hospital.algorithms.forEach((algo, idx) => {
                    const rowspan = idx === 0 ? ` rowspan="${hospital.algorithms.length}"` : '';
                    html += '<tr>';
                    if (idx === 0) {
                        html += `<td${rowspan}><strong>${hospital.hospital}</strong></td>`;
                    }
                    html += `<td>${algo.algorithm}</td>`;
                    html += `<td>${algo.distance_km ? algo.distance_km.toFixed(2) : 'N/A'}</td>`;
                    html += `<td>${algo.execution_time ? algo.execution_time.toFixed(4) : 'N/A'}</td>`;
                    html += `<td>${algo.nodes_processed || 'N/A'}</td>`;
                    html += '</tr>';
                });
            });
            
            html += '</tbody></table></div>';
            
            // Dibujar rutas en el mapa
            clearPaths();
            clearMarkers();
            
            // Marcar ubicaci√≥n del usuario
            const userMarker = L.marker([data.user_location.lat, data.user_location.lon], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41]
                })
            }).addTo(map).bindPopup('üöë Origen').openPopup();
            currentMarkers.push(userMarker);
            
            // Dibujar rutas y marcadores de hospitales
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'];
            data.hospital_routes.forEach((hospital, idx) => {
                // Marcar hospital
                const hospitalMarker = L.marker([hospital.hospital_location.lat, hospital.hospital_location.lon], {
                    icon: L.icon({
                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                        iconSize: [25, 41],
                        iconAnchor: [12, 41]
                    })
                }).addTo(map).bindPopup(`<strong>üè• ${hospital.hospital}</strong>`);
                currentMarkers.push(hospitalMarker);
                
                // Dibujar ruta (primer algoritmo)
                if (hospital.algorithms[0] && hospital.algorithms[0].path) {
                    const pathCoords = hospital.algorithms[0].path.map(p => [p.lat, p.lon]);
                    const polyline = L.polyline(pathCoords, {
                        color: colors[idx % colors.length],
                        weight: 4,
                        opacity: 0.7
                    }).addTo(map);
                    currentPaths.push(polyline);
                }
            });
            
            resultsDiv.innerHTML = html;
        }
        
        function clearPaths() {
            currentPaths.forEach(path => map.removeLayer(path));
            currentPaths = [];
        }
        
        // Comparar algoritmos
        async function compareAlgorithms() {
            const sourceNodeElement = document.getElementById('sourceNode');
            if (!sourceNodeElement) {
                showStatus('Campo sourceNode no encontrado', 'error');
                return;
            }
            
            const sourceNode = parseInt(sourceNodeElement.value);
            if (isNaN(sourceNode)) {
                showStatus('Ingrese un nodo de origen v√°lido', 'error');
                return;
            }
            
            const useCuda = document.getElementById('useCuda').checked;
            
            // Obtener algoritmos seleccionados
            const selectedAlgorithms = [];
            document.querySelectorAll('#algorithmCheckboxes input:checked').forEach(checkbox => {
                selectedAlgorithms.push(checkbox.value);
            });
            
            if (selectedAlgorithms.length === 0) {
                showStatus('Seleccione al menos un algoritmo', 'error');
                return;
            }
            
            document.getElementById('loadingDiv').classList.add('active');
            document.getElementById('resultsDiv').innerHTML = '';
            
            try {
                const response = await fetch(`${API_URL}/compare_algorithms`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        source_node: sourceNode,
                        algorithms: selectedAlgorithms,
                        use_cuda: useCuda
                    })
                });
                
                const data = await response.json();
                
                document.getElementById('loadingDiv').classList.remove('active');
                
                if (data.success) {
                    displayResults(data);
                    showStatus('‚úÖ Comparaci√≥n completada', 'success');
                } else {
                    showStatus('Error en la comparaci√≥n', 'error');
                }
            } catch (error) {
                document.getElementById('loadingDiv').classList.remove('active');
                showStatus(`Error: ${error.message}`, 'error');
            }
        }
        
        // Mostrar resultados
        function displayResults(data) {
            const resultsDiv = document.getElementById('resultsDiv');
            
            let html = '<div class="section"><h3>üìä Resultados de la Comparaci√≥n</h3>';
            
            // Tabla comparativa
            html += '<table class="comparison-table"><thead><tr>';
            html += '<th>Algoritmo</th><th>Tiempo (s)</th><th>Nodos Procesados</th>';
            html += '<th>Relajaciones</th><th>Memoria (MB)</th><th>Speedup</th>';
            html += '</tr></thead><tbody>';
            
            // Encontrar mejores valores
            let minTime = Infinity, minNodes = Infinity, minRelax = Infinity, minMem = Infinity;
            data.results.forEach(r => {
                if (r.metrics) {
                    minTime = Math.min(minTime, r.metrics.execution_time);
                    minNodes = Math.min(minNodes, r.metrics.nodes_processed);
                    minRelax = Math.min(minRelax, r.metrics.edge_relaxations);
                    minMem = Math.min(minMem, r.metrics.memory_peak_mb);
                }
            });
            
            data.results.forEach(result => {
                if (result.metrics) {
                    const m = result.metrics;
                    const speedup = data.comparison.speedup_vs_dijkstra[result.algorithm] || 1.0;
                    
                    html += '<tr>';
                    html += `<td><strong>${result.algorithm}</strong></td>`;
                    html += `<td ${m.execution_time === minTime ? 'class="best-value"' : ''}>${m.execution_time.toFixed(4)}</td>`;
                    html += `<td ${m.nodes_processed === minNodes ? 'class="best-value"' : ''}>${m.nodes_processed}</td>`;
                    html += `<td ${m.edge_relaxations === minRelax ? 'class="best-value"' : ''}>${m.edge_relaxations}</td>`;
                    html += `<td ${m.memory_peak_mb === minMem ? 'class="best-value"' : ''}>${m.memory_peak_mb.toFixed(2)}</td>`;
                    html += `<td>${speedup.toFixed(2)}x</td>`;
                    html += '</tr>';
                }
            });
            
            html += '</tbody></table></div>';
            
            // Gr√°ficos
            html += '<div class="chart-container"><canvas id="timeChart"></canvas></div>';
            html += '<div class="chart-container"><canvas id="metricsChart"></canvas></div>';
            
            resultsDiv.innerHTML = html;
            
            // Crear gr√°ficos
            createCharts(data.results);
        }
        
        // Crear gr√°ficos
        function createCharts(results) {
            const algorithms = results.map(r => r.algorithm);
            const times = results.map(r => r.metrics?.execution_time || 0);
            const nodes = results.map(r => r.metrics?.nodes_processed || 0);
            const relaxations = results.map(r => r.metrics?.edge_relaxations || 0);
            const memory = results.map(r => r.metrics?.memory_peak_mb || 0);
            
            // Gr√°fico de tiempos
            new Chart(document.getElementById('timeChart'), {
                type: 'bar',
                data: {
                    labels: algorithms,
                    datasets: [{
                        label: 'Tiempo de Ejecuci√≥n (s)',
                        data: times,
                        backgroundColor: 'rgba(102, 126, 234, 0.7)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Tiempo de Ejecuci√≥n por Algoritmo'
                        }
                    }
                }
            });
            
            // Gr√°fico de m√©tricas
            new Chart(document.getElementById('metricsChart'), {
                type: 'radar',
                data: {
                    labels: ['Nodos Procesados', 'Relajaciones', 'Memoria (MB)'],
                    datasets: algorithms.map((algo, idx) => ({
                        label: algo,
                        data: [
                            nodes[idx],
                            relaxations[idx],
                            memory[idx] * 100  // Escalar para visualizaci√≥n
                        ],
                        borderWidth: 2
                    }))
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Comparaci√≥n de M√©tricas'
                        }
                    }
                }
            });
        }
        
        // Utilidades
        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusDiv');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        function clearMarkers() {
            currentMarkers.forEach(marker => map.removeLayer(marker));
            currentMarkers = [];
        }
        
        // Obtener algoritmos seleccionados
        function getSelectedAlgorithms() {
            const algos = [];
            if (document.getElementById('algo_dijkstra')?.checked) algos.push('dijkstra');
            if (document.getElementById('algo_duan')?.checked) algos.push('duan2025');
            if (document.getElementById('algo_khanna')?.checked) algos.push('khanna2022');
            if (document.getElementById('algo_wang')?.checked) algos.push('wang2021');
            return algos.length > 0 ? algos : ['dijkstra', 'duan2025'];
        }
        
        // Mostrar resultados de rutas
        function displayRouteResults(data) {
            // Limpiar rutas anteriores
            currentPaths.forEach(path => map.removeLayer(path));
            currentPaths = [];
            
            // Colores para cada algoritmo
            const algorithmColors = {
                'dijkstra': '#e74c3c',
                'duan2025': '#3498db',
                'khanna2022': '#2ecc71',
                'wang2021': '#f39c12'
            };

            // Estilos para distinguir trazos aunque el camino sea el mismo
            const algorithmDash = {
                'dijkstra': null,
                'duan2025': '10, 6',
                'khanna2022': '2, 8',
                'wang2021': '14, 6, 2, 6'
            };
            
            const algorithmNames = {
                'dijkstra': 'Dijkstra',
                'duan2025': 'Duan et al. (2025)',
                'khanna2022': 'Khanna et al. (2022)',
                'wang2021': 'Wang et al. (2021)'
            };
            
            // Obtener algoritmos seleccionados
            const selectedAlgos = getSelectedAlgorithms();
            
            // Agrupar rutas exitosas por algoritmo
            const routesByAlgorithm = {};
            const successfulAlgos = new Set();
            
            if (data.routes && data.routes.length > 0) {
                data.routes.forEach(route => {
                    const algo = route.algorithm.toLowerCase();
                    if (!routesByAlgorithm[algo]) {
                        routesByAlgorithm[algo] = [];
                    }
                    routesByAlgorithm[algo].push(route);
                    successfulAlgos.add(algo);
                });
                
                // Dibujar rutas en el mapa con colores por algoritmo
                Object.entries(routesByAlgorithm).forEach(([algo, routes]) => {
                    routes.forEach((route, idx) => {
                        if (!route.path_coordinates || route.path_coordinates.length === 0) return;
                        
                        const color = algorithmColors[algo] || '#9b59b6';
                        const polyline = L.polyline(route.path_coordinates, {
                            color: color,
                            weight: 4,
                            opacity: 0.7,
                            dashArray: (algorithmDash[algo] !== undefined) ? algorithmDash[algo] : (idx > 0 ? '10, 5' : null)
                        }).addTo(map);
                        
                        polyline.bindPopup(`
                            <b>${route.hospital_name}</b><br>
                            <span style="color: ${color};">‚óè</span> Algoritmo: <b>${route.algorithm}</b><br>
                            Distancia: ${route.path_distance_km.toFixed(2)} km<br>
                            Tiempo: ${route.metrics.execution_time.toFixed(3)} s<br>
                            Nodos procesados: ${route.metrics.nodes_processed}
                        `);
                        
                        currentPaths.push(polyline);
                    });
                });
                
                // Ajustar el mapa para mostrar todas las rutas
                if (currentPaths.length > 0) {
                    const group = L.featureGroup(currentPaths);
                    map.fitBounds(group.getBounds().pad(0.1));
                }
            }
            
            // Mostrar tarjetas para TODOS los algoritmos seleccionados
            const resultsDiv = document.getElementById('resultsDiv');
            const cardsHTML = selectedAlgos.map(algo => {
                const algoKey = algo.toLowerCase();
                const color = algorithmColors[algoKey] || '#9b59b6';
                const algoName = algorithmNames[algoKey] || algo;
                
                if (successfulAlgos.has(algoKey)) {
                    // Algoritmo exitoso
                    const route = routesByAlgorithm[algoKey][0];
                    const metrics = route.metrics;
                    
                    return `
                        <div style="border: 2px solid ${color}; border-radius: 8px; padding: 15px; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <h4 style="margin: 0 0 10px 0; color: ${color}; display: flex; align-items: center;">
                                <span style="font-size: 1.5em; margin-right: 8px;">‚óè</span>
                                ${algoName}
                            </h4>
                            <div style="font-size: 0.9em; line-height: 1.6;">
                                <div style="margin-bottom: 8px;">
                                    <strong>üè• Hospital:</strong> ${route.hospital_name}
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <strong>üìè Distancia:</strong> ${route.path_distance_km.toFixed(2)} km
                                </div>
                                <hr style="border: none; border-top: 1px solid #eee; margin: 10px 0;">
                                <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
                                    <div style="margin-bottom: 5px;">
                                        <strong>‚è±Ô∏è Tiempo de ejecuci√≥n:</strong> ${(metrics.execution_time * 1000).toFixed(2)} ms
                                    </div>
                                    <div style="margin-bottom: 5px;">
                                        <strong>üî¢ Nodos procesados:</strong> ${metrics.nodes_processed.toLocaleString()}
                                    </div>
                                    <div style="margin-bottom: 5px;">
                                        <strong>üîÑ Relajaciones de aristas:</strong> ${metrics.edge_relaxations.toLocaleString()}
                                    </div>
                                    <div style="margin-bottom: 5px;">
                                        <strong>üíæ Uso de memoria:</strong> ${metrics.memory_peak_mb.toFixed(2)} MB
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    // Algoritmo fallido o sin resultados
                    return `
                        <div style="border: 2px solid #ccc; border-radius: 8px; padding: 15px; background: #f8f9fa; box-shadow: 0 2px 4px rgba(0,0,0,0.1); opacity: 0.7;">
                            <h4 style="margin: 0 0 10px 0; color: #666; display: flex; align-items: center;">
                                <span style="font-size: 1.5em; margin-right: 8px;">‚ö†Ô∏è</span>
                                ${algoName}
                            </h4>
                            <div style="font-size: 0.9em; line-height: 1.6; color: #666;">
                                <div style="padding: 15px; background: #fff3cd; border-radius: 5px; border-left: 4px solid #ffc107;">
                                    <strong>‚ùå No se pudo calcular la ruta</strong>
                                    <p style="margin: 8px 0 0 0; font-size: 0.85em;">
                                        Posibles causas: Error en el algoritmo, ruta no encontrada, o conversi√≥n de matriz sparse.
                                    </p>
                                </div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
            
            // Tabla y gr√°ficos (incluye fallos) a partir de algorithm_runs
            const runs = Array.isArray(data.algorithm_runs) ? data.algorithm_runs : [];
            const runByAlgo = {};
            runs.forEach(r => {
                if (!r || !r.algorithm) return;
                runByAlgo[String(r.algorithm).toLowerCase()] = r;
            });

            // Construir tabla: una fila por algoritmo seleccionado
            const tableRows = selectedAlgos.map(algo => {
                const key = algo.toLowerCase();
                const run = runByAlgo[key];
                const color = algorithmColors[key] || '#9b59b6';

                const ok = run?.success === true;
                const metrics = run?.metrics;
                const details = metrics?.details || {};

                const timeS = (metrics && typeof metrics.execution_time === 'number') ? metrics.execution_time : null;
                const nodesP = (metrics && typeof metrics.nodes_processed === 'number') ? metrics.nodes_processed : null;
                const relax = (metrics && typeof metrics.edge_relaxations === 'number') ? metrics.edge_relaxations : null;
                const mem = (metrics && typeof metrics.memory_peak_mb === 'number') ? metrics.memory_peak_mb : null;

                // Distancia: preferir run.path_distance_km; si no, tomar de routes
                let distKm = (run && typeof run.path_distance_km === 'number') ? run.path_distance_km : null;
                if (distKm === null && routesByAlgorithm[key] && routesByAlgorithm[key][0]) {
                    distKm = routesByAlgorithm[key][0].path_distance_km;
                }

                const mode = (details && typeof details.mode === 'string') ? details.mode : '';
                const variant = (details && typeof details.route_variant === 'string') ? details.route_variant : '';
                const err = run?.error ? String(run.error) : '';

                return `
                    <tr>
                        <td><span style="color:${color}; font-weight:700;">‚óè</span> ${algorithmNames[key] || algo}</td>
                        <td>${ok ? '<span style="color:#2e7d32; font-weight:700;">OK</span>' : '<span style="color:#c62828; font-weight:700;">ERR</span>'}</td>
                        <td>${distKm !== null ? distKm.toFixed(3) : 'N/A'}</td>
                        <td>${timeS !== null ? timeS.toFixed(4) : 'N/A'}</td>
                        <td>${nodesP !== null ? nodesP.toLocaleString() : 'N/A'}</td>
                        <td>${relax !== null ? relax.toLocaleString() : 'N/A'}</td>
                        <td>${mem !== null ? mem.toFixed(2) : 'N/A'}</td>
                        <td>${mode || 'N/A'}</td>
                        <td>${variant || ''}</td>
                        <td style="color:#666; font-size:0.85em;">${!ok ? err : ''}</td>
                    </tr>
                `;
            }).join('');

            resultsDiv.innerHTML = `
                <h3 style="margin-bottom: 15px;">üìä Resultados por Algoritmo</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">
                    ${cardsHTML}
                </div>
                
                <div style="margin-top: 20px; padding: 10px; background: #e8f5e9; border-radius: 5px; font-size: 0.85em;">
                    <strong>üí° Leyenda:</strong> 
                    ${selectedAlgos.map(algo => {
                        const algoKey = algo.toLowerCase();
                        const color = algorithmColors[algoKey] || '#9b59b6';
                        const algoName = algorithmNames[algoKey] || algo;
                        return `<span style="margin-left: 10px;"><span style="color: ${color};">‚óè</span> ${algoName}</span>`;
                    }).join('')}
                </div>

                <div style="margin-top: 18px;">
                    <h3 style="margin: 0 0 10px 0;">üìã Tabla comparativa (completa)</h3>
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Algoritmo</th>
                                <th>Estado</th>
                                <th>Distancia (km)</th>
                                <th>Tiempo (s)</th>
                                <th>Nodos Proc.</th>
                                <th>Relax. Aristas</th>
                                <th>Memoria (MB)</th>
                                <th>Modo</th>
                                <th>Variante</th>
                                <th>Detalle error</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                </div>

                <div class="chart-container"><canvas id="routeTimeChart"></canvas></div>
                <div class="chart-container"><canvas id="routeWorkChart"></canvas></div>
            `;

            // Gr√°ficos: destruir anteriores si existen
            window.__routeCharts = window.__routeCharts || { time: null, work: null };
            try { window.__routeCharts.time?.destroy(); } catch (_) {}
            try { window.__routeCharts.work?.destroy(); } catch (_) {}

            // Datos para gr√°ficos (solo m√©tricas num√©ricas disponibles)
            const chartLabels = selectedAlgos.map(a => (algorithmNames[a.toLowerCase()] || a));
            const times = selectedAlgos.map(a => {
                const m = runByAlgo[a.toLowerCase()]?.metrics;
                return (m && typeof m.execution_time === 'number') ? m.execution_time : 0;
            });
            const nodes = selectedAlgos.map(a => {
                const m = runByAlgo[a.toLowerCase()]?.metrics;
                return (m && typeof m.nodes_processed === 'number') ? m.nodes_processed : 0;
            });
            const relax = selectedAlgos.map(a => {
                const m = runByAlgo[a.toLowerCase()]?.metrics;
                return (m && typeof m.edge_relaxations === 'number') ? m.edge_relaxations : 0;
            });

            // Chart: Tiempo
            window.__routeCharts.time = new Chart(document.getElementById('routeTimeChart'), {
                type: 'bar',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: 'Tiempo (s)',
                        data: times,
                        backgroundColor: selectedAlgos.map(a => (algorithmColors[a.toLowerCase()] || '#9b59b6')),
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Tiempo por algoritmo' },
                        legend: { display: false }
                    },
                    scales: { y: { beginAtZero: true } }
                }
            });

            // Chart: Trabajo (nodos y relajaciones)
            window.__routeCharts.work = new Chart(document.getElementById('routeWorkChart'), {
                type: 'bar',
                data: {
                    labels: chartLabels,
                    datasets: [
                        {
                            label: 'Nodos procesados',
                            data: nodes,
                            backgroundColor: 'rgba(102, 126, 234, 0.65)'
                        },
                        {
                            label: 'Relajaciones',
                            data: relax,
                            backgroundColor: 'rgba(244, 67, 54, 0.55)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Trabajo interno (nodos/relajaciones)' }
                    },
                    scales: { y: { beginAtZero: true } }
                }
            });
            
            const successCount = successfulAlgos.size;
            const totalCount = selectedAlgos.length;
            if (successCount > 0) {
                showStatus(`‚úÖ ${successCount}/${totalCount} algoritmos completados exitosamente`, 'success');
            } else {
                showStatus(`‚ö†Ô∏è Ning√∫n algoritmo pudo calcular la ruta`, 'error');
            }
        }
        
        // Mostrar/ocultar informaci√≥n de CUDA
        async function toggleCudaInfo() {
            const checkbox = document.getElementById('useCuda');
            const infoDiv = document.getElementById('cudaInfo');
            
            if (checkbox.checked) {
                infoDiv.style.display = 'block';
                infoDiv.innerHTML = '<p style="margin:0;">‚è≥ Obteniendo informaci√≥n del sistema...</p>';
                
                try {
                    const response = await fetch(`${API_URL}/system_info`);
                    const data = await response.json();
                    
                    if (data.success) {
                        const sys = data.system;
                        const cuda = data.cuda;
                        
                        let html = `<strong style="color: #1976d2;">${data.recommendation}</strong><br>`;
                        
                        // Informaci√≥n de GPU si est√° disponible
                        if (cuda.available && cuda.devices && cuda.devices.length > 0) {
                            const gpu = cuda.devices[0];
                            html += `
                                <div style="margin-top: 8px; padding: 8px; background: #e8f5e9; border-radius: 4px; font-size: 0.85em;">
                                    <strong>üéÆ GPU:</strong> ${gpu.name}<br>
                                    <strong>Compute:</strong> ${gpu.compute_capability} | <strong>CUDA Cores:</strong> ${gpu.cuda_cores}<br>
                                    <strong>VRAM Total:</strong> ${gpu.total_memory_gb.toFixed(1)} GB | <strong>Libre:</strong> ${gpu.free_memory_gb.toFixed(1)} GB<br>
                                    <strong>Clock:</strong> ${gpu.clock_rate_mhz.toFixed(0)} MHz | <strong>Bus:</strong> ${gpu.memory_bus_width}-bit<br>
                                    <small style="color: #555;">CUDA ${(cuda.version/1000).toFixed(1)} | Driver ${(cuda.driver_version/1000).toFixed(1)}</small>
                                </div>
                            `;
                        } else {
                            html += `
                                <div style="margin-top: 8px; padding: 8px; background: #fff3cd; border-radius: 4px; font-size: 0.85em;">
                                    <strong>‚ö†Ô∏è Sin GPU NVIDIA</strong><br>
                                    <small>${cuda.message || 'GPU no disponible'}</small><br>
                                    ${cuda.install_command ? `<code style="background: #f5f5f5; padding: 2px 4px; border-radius: 2px;">${cuda.install_command}</code>` : ''}
                                </div>
                            `;
                        }
                        
                        // Informaci√≥n de CPU y RAM
                        html += `
                            <div style="margin-top: 8px; padding: 8px; background: #f5f5f5; border-radius: 4px; font-size: 0.85em;">
                                <strong>üíª CPU:</strong> ${sys.cpu.cores_physical} n√∫cleos f√≠sicos (${sys.cpu.cores_logical} l√≥gicos)<br>
                                <strong>Frecuencia:</strong> ${sys.cpu.frequency_mhz.toFixed(0)} MHz | <strong>Uso:</strong> ${sys.cpu.usage_percent.toFixed(1)}%<br>
                                <strong>üß† RAM:</strong> ${sys.ram.total_gb.toFixed(1)} GB Total | <strong>Usado:</strong> ${sys.ram.used_gb.toFixed(1)} GB (${sys.ram.percent_used.toFixed(0)}%)<br>
                                <strong>Disponible:</strong> ${sys.ram.available_gb.toFixed(1)} GB
                            </div>
                        `;
                        
                        infoDiv.innerHTML = html;
                    } else {
                        infoDiv.innerHTML = '<p style="margin:0; color: #d32f2f;">‚ùå Error al obtener informaci√≥n del sistema</p>';
                    }
                } catch (error) {
                    infoDiv.innerHTML = `<p style="margin:0; color: #d32f2f;">‚ùå Error: ${error.message}</p>`;
                    console.error('Error fetching system info:', error);
                }
            } else {
                infoDiv.style.display = 'none';
            }
        }
        
        // Inicializaci√≥n
        window.onload = function() {
            initMap();
            loadRegions();
            toggleCudaInfo(); // Mostrar info de CUDA al iniciar
        };
    </script>
</body>
</html>
